[1mdiff --git a/venv/Lib/site-packages/MarkupSafe-3.0.2.dist-info/INSTALLER b/venv/Lib/site-packages/MarkupSafe-3.0.2.dist-info/INSTALLER[m
[1mnew file mode 100644[m
[1mindex 0000000..a1b589e[m
[1m--- /dev/null[m
[1m+++ b/venv/Lib/site-packages/MarkupSafe-3.0.2.dist-info/INSTALLER[m
[36m@@ -0,0 +1 @@[m
[32m+[m[32mpip[m
[1mdiff --git a/venv/Lib/site-packages/MarkupSafe-3.0.2.dist-info/LICENSE.txt b/venv/Lib/site-packages/MarkupSafe-3.0.2.dist-info/LICENSE.txt[m
[1mnew file mode 100644[m
[1mindex 0000000..9d227a0[m
[1m--- /dev/null[m
[1m+++ b/venv/Lib/site-packages/MarkupSafe-3.0.2.dist-info/LICENSE.txt[m
[36m@@ -0,0 +1,28 @@[m
[32m+[m[32mCopyright 2010 Pallets[m
[32m+[m
[32m+[m[32mRedistribution and use in source and binary forms, with or without[m
[32m+[m[32mmodification, are permitted provided that the following conditions are[m
[32m+[m[32mmet:[m
[32m+[m
[32m+[m[32m1.  Redistributions of source code must retain the above copyright[m
[32m+[m[32m    notice, this list of conditions and the following disclaimer.[m
[32m+[m
[32m+[m[32m2.  Redistributions in binary form must reproduce the above copyright[m
[32m+[m[32m    notice, this list of conditions and the following disclaimer in the[m
[32m+[m[32m    documentation and/or other materials provided with the distribution.[m
[32m+[m
[32m+[m[32m3.  Neither the name of the copyright holder nor the names of its[m
[32m+[m[32m    contributors may be used to endorse or promote products derived from[m
[32m+[m[32m    this software without specific prior written permission.[m
[32m+[m
[32m+[m[32mTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS[m
[32m+[m[32m"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT[m
[32m+[m[32mLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A[m
[32m+[m[32mPARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT[m
[32m+[m[32mHOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,[m
[32m+[m[32mSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED[m
[32m+[m[32mTO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR[m
[32m+[m[32mPROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF[m
[32m+[m[32mLIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING[m
[32m+[m[32mNEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS[m
[32m+[m[32mSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.[m
[1mdiff --git a/venv/Lib/site-packages/MarkupSafe-3.0.2.dist-info/METADATA b/venv/Lib/site-packages/MarkupSafe-3.0.2.dist-info/METADATA[m
[1mnew file mode 100644[m
[1mindex 0000000..82261f2[m
[1m--- /dev/null[m
[1m+++ b/venv/Lib/site-packages/MarkupSafe-3.0.2.dist-info/METADATA[m
[36m@@ -0,0 +1,92 @@[m
[32m+[m[32mMetadata-Version: 2.1[m
[32m+[m[32mName: MarkupSafe[m
[32m+[m[32mVersion: 3.0.2[m
[32m+[m[32mSummary: Safely add untrusted strings to HTML/XML markup.[m
[32m+[m[32mMaintainer-email: Pallets <contact@palletsprojects.com>[m
[32m+[m[32mLicense: Copyright 2010 Pallets[m
[32m+[m[41m        [m
[32m+[m[32m        Redistribution and use in source and binary forms, with or without[m
[32m+[m[32m        modification, are permitted provided that the following conditions are[m
[32m+[m[32m        met:[m
[32m+[m[41m        [m
[32m+[m[32m        1.  Redistributions of source code must retain the above copyright[m
[32m+[m[32m            notice, this list of conditions and the following disclaimer.[m
[32m+[m[41m        [m
[32m+[m[32m        2.  Redistributions in binary form must reproduce the above copyright[m
[32m+[m[32m            notice, this list of conditions and the following disclaimer in the[m
[32m+[m[32m            documentation and/or other materials provided with the distribution.[m
[32m+[m[41m        [m
[32m+[m[32m        3.  Neither the name of the copyright holder nor the names of its[m
[32m+[m[32m            contributors may be used to endorse or promote products derived from[m
[32m+[m[32m            this software without specific prior written permission.[m
[32m+[m[41m        [m
[32m+[m[32m        THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS[m
[32m+[m[32m        "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT[m
[32m+[m[32m        LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A[m
[32m+[m[32m        PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT[m
[32m+[m[32m        HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,[m
[32m+[m[32m        SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED[m
[32m+[m[32m        TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR[m
[32m+[m[32m        PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF[m
[32m+[m[32m        LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING[m
[32m+[m[32m        NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS[m
[32m+[m[32m        SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.[m
[32m+[m[41m        [m
[32m+[m[32mProject-URL: Donate, https://palletsprojects.com/donate[m
[32m+[m[32mProject-URL: Documentation, https://markupsafe.palletsprojects.com/[m
[32m+[m[32mProject-URL: Changes, https://markupsafe.palletsprojects.com/changes/[m
[32m+[m[32mProject-URL: Source, https://github.com/pallets/markupsafe/[m
[32m+[m[32mProject-URL: Chat, https://discord.gg/pallets[m
[32m+[m[32mClassifier: Development Status :: 5 - Production/Stable[m
[32m+[m[32mClassifier: Environment :: Web Environment[m
[32m+[m[32mClassifier: Intended Audience :: Developers[m
[32m+[m[32mClassifier: License :: OSI Approved :: BSD License[m
[32m+[m[32mClassifier: Operating System :: OS Independent[m
[32m+[m[32mClassifier: Programming Language :: Python[m
[32m+[m[32mClassifier: Topic :: Internet :: WWW/HTTP :: Dynamic Content[m
[32m+[m[32mClassifier: Topic :: Text Processing :: Markup :: HTML[m
[32m+[m[32mClassifier: Typing :: Typed[m
[32m+[m[32mRequires-Python: >=3.9[m
[32m+[m[32mDescription-Content-Type: text/markdown[m
[32m+[m[32mLicense-File: LICENSE.txt[m
[32m+[m
[32m+[m[32m# MarkupSafe[m
[32m+[m
[32m+[m[32mMarkupSafe implements a text object that escapes characters so it is[m
[32m+[m[32msafe to use in HTML and XML. Characters that have special meanings are[m
[32m+[m[32mreplaced so that they display as the actual characters. This mitigates[m
[32m+[m[32minjection attacks, meaning untrusted user input can safely be displayed[m
[32m+[m[32mon a page.[m
[32m+[m
[32m+[m
[32m+[m[32m## Examples[m
[32m+[m
[32m+[m[32m```pycon[m
[32m+[m[32m>>> from markupsafe import Markup, escape[m
[32m+[m
[32m+[m[32m>>> # escape replaces special characters and wraps in Markup[m
[32m+[m[32m>>> escape("<script>alert(document.cookie);</script>")[m
[32m+[m[32mMarkup('&lt;script&gt;alert(document.cookie);&lt;/script&gt;')[m
[32m+[m
[32m+[m[32m>>> # wrap in Markup to mark text "safe" and prevent escaping[m
[32m+[m[32m>>> Markup("<strong>Hello</strong>")[m
[32m+[m[32mMarkup('<strong>hello</strong>')[m
[32m+[m
[32m+[m[32m>>> escape(Markup("<strong>Hello</strong>"))[m
[32m+[m[32mMarkup('<strong>hello</strong>')[m
[32m+[m
[32m+[m[32m>>> # Markup is a str subclass[m
[32m+[m[32m>>> # methods and operators escape their arguments[m
[32m+[m[32m>>> template = Markup("Hello <em>{name}</em>")[m
[32m+[m[32m>>> template.format(name='"World"')[m
[32m+[m[32mMarkup('Hello <em>&#34;World&#34;</em>')[m
[32m+[m[32m```[m
[32m+[m
[32m+[m[32m## Donate[m
[32m+[m
[32m+[m[32mThe Pallets organization develops and supports MarkupSafe and other[m
[32m+[m[32mpopular packages. In order to grow the community of contributors and[m
[32m+[m[32musers, and allow the maintainers to devote more time to the projects,[m
[32m+[m[32m[please donate today][].[m
[32m+[m
[32m+[m[32m[please donate today]: https://palletsprojects.com/donate[m
[1mdiff --git a/venv/Lib/site-packages/MarkupSafe-3.0.2.dist-info/RECORD b/venv/Lib/site-packages/MarkupSafe-3.0.2.dist-info/RECORD[m
[1mnew file mode 100644[m
[1mindex 0000000..26bf81c[m
[1m--- /dev/null[m
[1m+++ b/venv/Lib/site-packages/MarkupSafe-3.0.2.dist-info/RECORD[m
[36m@@ -0,0 +1,14 @@[m
[32m+[m[32mMarkupSafe-3.0.2.dist-info/INSTALLER,sha256=zuuue4knoyJ-UwPPXg8fezS7VCrXJQrAP7zeNuwvFQg,4[m
[32m+[m[32mMarkupSafe-3.0.2.dist-info/LICENSE.txt,sha256=RjHsDbX9kKVH4zaBcmTGeYIUM4FG-KyUtKV_lu6MnsQ,1503[m
[32m+[m[32mMarkupSafe-3.0.2.dist-info/METADATA,sha256=nhoabjupBG41j_JxPCJ3ylgrZ6Fx8oMCFbiLF9Kafqc,4067[m
[32m+[m[32mMarkupSafe-3.0.2.dist-info/RECORD,,[m
[32m+[m[32mMarkupSafe-3.0.2.dist-info/WHEEL,sha256=62QJgqtUFevqILau0n0UncooEMoOyVCKVQitJpcuCig,101[m
[32m+[m[32mMarkupSafe-3.0.2.dist-info/top_level.txt,sha256=qy0Plje5IJuvsCBjejJyhDCjEAdcDLK_2agVcex8Z6U,11[m
[32m+[m[32mmarkupsafe/__init__.py,sha256=pREerPwvinB62tNCMOwqxBS2YHV6R52Wcq1d-rB4Z5o,13609[m
[32m+[m[32mmarkupsafe/__pycache__/__init__.cpython-312.pyc,,[m
[32m+[m[32mmarkupsafe/__pycache__/_native.cpython-312.pyc,,[m
[32m+[m[32mmarkupsafe/_native.py,sha256=2ptkJ40yCcp9kq3L1NqpgjfpZB-obniYKFFKUOkHh4Q,218[m
[32m+[m[32mmarkupsafe/_speedups.c,sha256=SglUjn40ti9YgQAO--OgkSyv9tXq9vvaHyVhQows4Ok,4353[m
[32m+[m[32mmarkupsafe/_speedups.cp312-win_amd64.pyd,sha256=sC88mCi7HJOQhbSSrdMPZfdCvi_VBfOzwkVuQ7V6T3M,13312[m
[32m+[m[32mmarkupsafe/_speedups.pyi,sha256=LSDmXYOefH4HVpAXuL8sl7AttLw0oXh1njVoVZp2wqQ,42[m
[32m+[m[32mmarkupsafe/py.typed,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0[m
[1mdiff --git a/venv/Lib/site-packages/MarkupSafe-3.0.2.dist-info/WHEEL b/venv/Lib/site-packages/MarkupSafe-3.0.2.dist-info/WHEEL[m
[1mnew file mode 100644[m
[1mindex 0000000..bd4c259[m
[1m--- /dev/null[m
[1m+++ b/venv/Lib/site-packages/MarkupSafe-3.0.2.dist-info/WHEEL[m
[36m@@ -0,0 +1,5 @@[m
[32m+[m[32mWheel-Version: 1.0[m
[32m+[m[32mGenerator: setuptools (75.2.0)[m
[32m+[m[32mRoot-Is-Purelib: false[m
[32m+[m[32mTag: cp312-cp312-win_amd64[m
[32m+[m
[1mdiff --git a/venv/Lib/site-packages/MarkupSafe-3.0.2.dist-info/top_level.txt b/venv/Lib/site-packages/MarkupSafe-3.0.2.dist-info/top_level.txt[m
[1mnew file mode 100644[m
[1mindex 0000000..75bf729[m
[1m--- /dev/null[m
[1m+++ b/venv/Lib/site-packages/MarkupSafe-3.0.2.dist-info/top_level.txt[m
[36m@@ -0,0 +1 @@[m
[32m+[m[32mmarkupsafe[m
[1mdiff --git a/venv/Lib/site-packages/blinker-1.9.0.dist-info/INSTALLER b/venv/Lib/site-packages/blinker-1.9.0.dist-info/INSTALLER[m
[1mnew file mode 100644[m
[1mindex 0000000..a1b589e[m
[1m--- /dev/null[m
[1m+++ b/venv/Lib/site-packages/blinker-1.9.0.dist-info/INSTALLER[m
[36m@@ -0,0 +1 @@[m
[32m+[m[32mpip[m
[1mdiff --git a/venv/Lib/site-packages/blinker-1.9.0.dist-info/LICENSE.txt b/venv/Lib/site-packages/blinker-1.9.0.dist-info/LICENSE.txt[m
[1mnew file mode 100644[m
[1mindex 0000000..79c9825[m
[1m--- /dev/null[m
[1m+++ b/venv/Lib/site-packages/blinker-1.9.0.dist-info/LICENSE.txt[m
[36m@@ -0,0 +1,20 @@[m
[32m+[m[32mCopyright 2010 Jason Kirtland[m
[32m+[m
[32m+[m[32mPermission is hereby granted, free of charge, to any person obtaining a[m
[32m+[m[32mcopy of this software and associated documentation files (the[m
[32m+[m[32m"Software"), to deal in the Software without restriction, including[m
[32m+[m[32mwithout limitation the rights to use, copy, modify, merge, publish,[m
[32m+[m[32mdistribute, sublicense, and/or sell copies of the Software, and to[m
[32m+[m[32mpermit persons to whom the Software is furnished to do so, subject to[m
[32m+[m[32mthe following conditions:[m
[32m+[m
[32m+[m[32mThe above copyright notice and this permission notice shall be included[m
[32m+[m[32min all copies or substantial portions of the Software.[m
[32m+[m
[32m+[m[32mTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS[m
[32m+[m[32mOR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF[m
[32m+[m[32mMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.[m
[32m+[m[32mIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY[m
[32m+[m[32mCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,[m
[32m+[m[32mTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE[m
[32m+[m[32mSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.[m
[1mdiff --git a/venv/Lib/site-packages/blinker-1.9.0.dist-info/METADATA b/venv/Lib/site-packages/blinker-1.9.0.dist-info/METADATA[m
[1mnew file mode 100644[m
[1mindex 0000000..6d343f5[m
[1m--- /dev/null[m
[1m+++ b/venv/Lib/site-packages/blinker-1.9.0.dist-info/METADATA[m
[36m@@ -0,0 +1,60 @@[m
[32m+[m[32mMetadata-Version: 2.3[m
[32m+[m[32mName: blinker[m
[32m+[m[32mVersion: 1.9.0[m
[32m+[m[32mSummary: Fast, simple object-to-object and broadcast signaling[m
[32m+[m[32mAuthor: Jason Kirtland[m
[32m+[m[32mMaintainer-email: Pallets Ecosystem <contact@palletsprojects.com>[m
[32m+[m[32mRequires-Python: >=3.9[m
[32m+[m[32mDescription-Content-Type: text/markdown[m
[32m+[m[32mClassifier: Development Status :: 5 - Production/Stable[m
[32m+[m[32mClassifier: License :: OSI Approved :: MIT License[m
[32m+[m[32mClassifier: Programming Language :: Python[m
[32m+[m[32mClassifier: Typing :: Typed[m
[32m+[m[32mProject-URL: Chat, https://discord.gg/pallets[m
[32m+[m[32mProject-URL: Documentation, https://blinker.readthedocs.io[m
[32m+[m[32mProject-URL: Source, https://github.com/pallets-eco/blinker/[m
[32m+[m
[32m+[m[32m# Blinker[m
[32m+[m
[32m+[m[32mBlinker provides a fast dispatching system that allows any number of[m
[32m+[m[32minterested parties to subscribe to events, or "signals".[m
[32m+[m
[32m+[m
[32m+[m[32m## Pallets Community Ecosystem[m
[32m+[m
[32m+[m[32m> [!IMPORTANT]\[m
[32m+[m[32m> This project is part of the Pallets Community Ecosystem. Pallets is the open[m
[32m+[m[32m> source organization that maintains Flask; Pallets-Eco enables community[m
[32m+[m[32m> maintenance of related projects. If you are interested in helping maintain[m
[32m+[m[32m> this project, please reach out on [the Pallets Discord server][discord].[m
[32m+[m[32m>[m
[32m+[m[32m> [discord]: https://discord.gg/pallets[m
[32m+[m
[32m+[m
[32m+[m[32m## Example[m
[32m+[m
[32m+[m[32mSignal receivers can subscribe to specific senders or receive signals[m
[32m+[m[32msent by any sender.[m
[32m+[m
[32m+[m[32m```pycon[m
[32m+[m[32m>>> from blinker import signal[m
[32m+[m[32m>>> started = signal('round-started')[m
[32m+[m[32m>>> def each(round):[m
[32m+[m[32m...     print(f"Round {round}")[m
[32m+[m[32m...[m
[32m+[m[32m>>> started.connect(each)[m
[32m+[m
[32m+[m[32m>>> def round_two(round):[m
[32m+[m[32m...     print("This is round two.")[m
[32m+[m[32m...[m
[32m+[m[32m>>> started.connect(round_two, sender=2)[m
[32m+[m
[32m+[m[32m>>> for round in range(1, 4):[m
[32m+[m[32m...     started.send(round)[m
[32m+[m[32m...[m
[32m+[m[32mRound 1![m
[32m+[m[32mRound 2![m
[32m+[m[32mThis is round two.[m
[32m+[m[32mRound 3![m
[32m+[m[32m```[m
[32m+[m
[1mdiff --git a/venv/Lib/site-packages/blinker-1.9.0.dist-info/RECORD b/venv/Lib/site-packages/blinker-1.9.0.dist-info/RECORD[m
[1mnew file mode 100644[m
[1mindex 0000000..d4f985b[m
[1m--- /dev/null[m
[1m+++ b/venv/Lib/site-packages/blinker-1.9.0.dist-info/RECORD[m
[36m@@ -0,0 +1,12 @@[m
[32m+[m[32mblinker-1.9.0.dist-info/INSTALLER,sha256=zuuue4knoyJ-UwPPXg8fezS7VCrXJQrAP7zeNuwvFQg,4[m
[32m+[m[32mblinker-1.9.0.dist-info/LICENSE.txt,sha256=nrc6HzhZekqhcCXSrhvjg5Ykx5XphdTw6Xac4p-spGc,1054[m
[32m+[m[32mblinker-1.9.0.dist-info/METADATA,sha256=uIRiM8wjjbHkCtbCyTvctU37IAZk0kEe5kxAld1dvzA,1633[m
[32m+[m[32mblinker-1.9.0.dist-info/RECORD,,[m
[32m+[m[32mblinker-1.9.0.dist-info/WHEEL,sha256=CpUCUxeHQbRN5UGRQHYRJorO5Af-Qy_fHMctcQ8DSGI,82[m
[32m+[m[32mblinker/__init__.py,sha256=I2EdZqpy4LyjX17Hn1yzJGWCjeLaVaPzsMgHkLfj_cQ,317[m
[32m+[m[32mblinker/__pycache__/__init__.cpython-312.pyc,,[m
[32m+[m[32mblinker/__pycache__/_utilities.cpython-312.pyc,,[m
[32m+[m[32mblinker/__pycache__/base.cpython-312.pyc,,[m
[32m+[m[32mblinker/_utilities.py,sha256=0J7eeXXTUx0Ivf8asfpx0ycVkp0Eqfqnj117x2mYX9E,1675[m
[32m+[m[32mblinker/base.py,sha256=QpDuvXXcwJF49lUBcH5BiST46Rz9wSG7VW_p7N_027M,19132[m
[32m+[m[32mblinker/py.typed,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0[m
[1mdiff --git a/venv/Lib/site-packages/blinker-1.9.0.dist-info/WHEEL b/venv/Lib/site-packages/blinker-1.9.0.dist-info/WHEEL[m
[1mnew file mode 100644[m
[1mindex 0000000..e3c6fee[m
[1m--- /dev/null[m
[1m+++ b/venv/Lib/site-packages/blinker-1.9.0.dist-info/WHEEL[m
[36m@@ -0,0 +1,4 @@[m
[32m+[m[32mWheel-Version: 1.0[m
[32m+[m[32mGenerator: flit 3.10.1[m
[32m+[m[32mRoot-Is-Purelib: true[m
[32m+[m[32mTag: py3-none-any[m
[1mdiff --git a/venv/Lib/site-packages/blinker/__init__.py b/venv/Lib/site-packages/blinker/__init__.py[m
[1mnew file mode 100644[m
[1mindex 0000000..1772fa4[m
[1m--- /dev/null[m
[1m+++ b/venv/Lib/site-packages/blinker/__init__.py[m
[36m@@ -0,0 +1,17 @@[m
[32m+[m[32mfrom __future__ import annotations[m
[32m+[m
[32m+[m[32mfrom .base import ANY[m
[32m+[m[32mfrom .base import default_namespace[m
[32m+[m[32mfrom .base import NamedSignal[m
[32m+[m[32mfrom .base import Namespace[m
[32m+[m[32mfrom .base import Signal[m
[32m+[m[32mfrom .base import signal[m
[32m+[m
[32m+[m[32m__all__ = [[m
[32m+[m[32m    "ANY",[m
[32m+[m[32m    "default_namespace",[m
[32m+[m[32m    "NamedSignal",[m
[32m+[m[32m    "Namespace",[m
[32m+[m[32m    "Signal",[m
[32m+[m[32m    "signal",[m
[32m+[m[32m][m
[1mdiff --git a/venv/Lib/site-packages/blinker/__pycache__/__init__.cpython-312.pyc b/venv/Lib/site-packages/blinker/__pycache__/__init__.cpython-312.pyc[m
[1mnew file mode 100644[m
[1mindex 0000000..6c7ffc3[m
Binary files /dev/null and b/venv/Lib/site-packages/blinker/__pycache__/__init__.cpython-312.pyc differ
[1mdiff --git a/venv/Lib/site-packages/blinker/__pycache__/_utilities.cpython-312.pyc b/venv/Lib/site-packages/blinker/__pycache__/_utilities.cpython-312.pyc[m
[1mnew file mode 100644[m
[1mindex 0000000..15258f5[m
Binary files /dev/null and b/venv/Lib/site-packages/blinker/__pycache__/_utilities.cpython-312.pyc differ
[1mdiff --git a/venv/Lib/site-packages/blinker/__pycache__/base.cpython-312.pyc b/venv/Lib/site-packages/blinker/__pycache__/base.cpython-312.pyc[m
[1mnew file mode 100644[m
[1mindex 0000000..f79da6a[m
Binary files /dev/null and b/venv/Lib/site-packages/blinker/__pycache__/base.cpython-312.pyc differ
[1mdiff --git a/venv/Lib/site-packages/blinker/_utilities.py b/venv/Lib/site-packages/blinker/_utilities.py[m
[1mnew file mode 100644[m
[1mindex 0000000..000c902[m
[1m--- /dev/null[m
[1m+++ b/venv/Lib/site-packages/blinker/_utilities.py[m
[36m@@ -0,0 +1,64 @@[m
[32m+[m[32mfrom __future__ import annotations[m
[32m+[m
[32m+[m[32mimport collections.abc as c[m
[32m+[m[32mimport inspect[m
[32m+[m[32mimport typing as t[m
[32m+[m[32mfrom weakref import ref[m
[32m+[m[32mfrom weakref import WeakMethod[m
[32m+[m
[32m+[m[32mT = t.TypeVar("T")[m
[32m+[m
[32m+[m
[32m+[m[32mclass Symbol:[m
[32m+[m[32m    """A constant symbol, nicer than ``object()``. Repeated calls return the[m
[32m+[m[32m    same instance.[m
[32m+[m
[32m+[m[32m    >>> Symbol('foo') is Symbol('foo')[m
[32m+[m[32m    True[m
[32m+[m[32m    >>> Symbol('foo')[m
[32m+[m[32m    foo[m
[32m+[m[32m    """[m
[32m+[m
[32m+[m[32m    symbols: t.ClassVar[dict[str, Symbol]] = {}[m
[32m+[m
[32m+[m[32m    def __new__(cls, name: str) -> Symbol:[m
[32m+[m[32m        if name in cls.symbols:[m
[32m+[m[32m            return cls.symbols[name][m
[32m+[m
[32m+[m[32m        obj = super().__new__(cls)[m
[32m+[m[32m        cls.symbols[name] = obj[m
[32m+[m[32m        return obj[m
[32m+[m
[32m+[m[32m    def __init__(self, name: str) -> None:[m
[32m+[m[32m        self.name = name[m
[32m+[m
[32m+[m[32m    def __repr__(self) -> str:[m
[32m+[m[32m        return self.name[m
[32m+[m
[32m+[m[32m    def __getnewargs__(self) -> tuple[t.Any, ...]:[m
[32m+[m[32m        return (self.name,)[m
[32m+[m
[32m+[m
[32m+[m[32mdef make_id(obj: object) -> c.Hashable:[m
[32m+[m[32m    """Get a stable identifier for a receiver or sender, to be used as a dict[m
[32m+[m[32m    key or in a set.[m
[32m+[m[32m    """[m
[32m+[m[32m    if inspect.ismethod(obj):[m
[32m+[m[32m        # The id of a bound method is not stable, but the id of the unbound[m
[32m+[m[32m        # function and instance are.[m
[32m+[m[32m        return id(obj.__func__), id(obj.__self__)[m
[32m+[m
[32m+[m[32m    if isinstance(obj, (str, int)):[m
[32m+[m[32m        # Instances with the same value always compare equal and have the same[m
[32m+[m[32m        # hash, even if the id may change.[m
[32m+[m[32m        return obj[m
[32m+[m
[32m+[m[32m    # Assume other types are not hashable but will always be the same instance.[m
[32m+[m[32m    return id(obj)[m
[32m+[m
[32m+[m
[32m+[m[32mdef make_ref(obj: T, callback: c.Callable[[ref[T]], None] | None = None) -> ref[T]:[m
[32m+[m[32m    if inspect.ismethod(obj):[m
[32m+[m[32m        return WeakMethod(obj, callback)  # type: ignore[arg-type, return-value][m
[32m+[m
[32m+[m[32m    return ref(obj, callback)[m
[1mdiff --git a/venv/Lib/site-packages/blinker/base.py b/venv/Lib/site-packages/blinker/base.py[m
[1mnew file mode 100644[m
[1mindex 0000000..d051b94[m
[1m--- /dev/null[m
[1m+++ b/venv/Lib/site-packages/blinker/base.py[m
[36m@@ -0,0 +1,512 @@[m
[32m+[m[32mfrom __future__ import annotations[m
[32m+[m
[32m+[m[32mimport collections.abc as c[m
[32m+[m[32mimport sys[m
[32m+[m[32mimport typing as t[m
[32m+[m[32mimport weakref[m
[32m+[m[32mfrom collections import defaultdict[m
[32m+[m[32mfrom contextlib import contextmanager[m
[32m+[m[32mfrom functools import cached_property[m
[32m+[m[32mfrom inspect import iscoroutinefunction[m
[32m+[m
[32m+[m[32mfrom ._utilities import make_id[m
[32m+[m[32mfrom ._utilities import make_ref[m
[32m+[m[32mfrom ._utilities import Symbol[m
[32m+[m
[32m+[m[32mF = t.TypeVar("F", bound=c.Callable[..., t.Any])[m
[32m+[m
[32m+[m[32mANY = Symbol("ANY")[m
[32m+[m[32m"""Symbol for "any sender"."""[m
[32m+[m
[32m+[m[32mANY_ID = 0[m
[32m+[m
[32m+[m
[32m+[m[32mclass Signal:[m
[32m+[m[32m    """A notification emitter.[m
[32m+[m
[32m+[m[32m    :param doc: The docstring for the signal.[m
[32m+[m[32m    """[m
[32m+[m
[32m+[m[32m    ANY = ANY[m
[32m+[m[32m    """An alias for the :data:`~blinker.ANY` sender symbol."""[m
[32m+[m
[32m+[m[32m    set_class: type[set[t.Any]] = set[m
[32m+[m[32m    """The set class to use for tracking connected receivers and senders.[m
[32m+[m[32m    Python's ``set`` is unordered. If receivers must be dispatched in the order[m
[32m+[m[32m    they were connected, an ordered set implementation can be used.[m
[32m+[m
[32m+[m[32m    .. versionadded:: 1.7[m
[32m+[m[32m    """[m
[32m+[m
[32m+[m[32m    @cached_property[m
[32m+[m[32m    def receiver_connected(self) -> Signal:[m
[32m+[m[32m        """Emitted at the end of each :meth:`connect` call.[m
[32m+[m
[32m+[m[32m        The signal sender is the signal instance, and the :meth:`connect`[m
[32m+[m[32m        arguments are passed through: ``receiver``, ``sender``, and ``weak``.[m
[32m+[m
[32m+[m[32m        .. versionadded:: 1.2[m
[32m+[m[32m        """[m
[32m+[m[32m        return Signal(doc="Emitted after a receiver connects.")[m
[32m+[m
[32m+[m[32m    @cached_property[m
[32m+[m[32m    def receiver_disconnected(self) -> Signal:[m
[32m+[m[32m        """Emitted at the end of each :meth:`disconnect` call.[m
[32m+[m
[32m+[m[32m        The sender is the signal instance, and the :meth:`disconnect` arguments[m
[32m+[m[32m        are passed through: ``receiver`` and ``sender``.[m
[32m+[m
[32m+[m[32m        This signal is emitted **only** when :meth:`disconnect` is called[m
[32m+[m[32m        explicitly. This signal cannot be emitted by an automatic disconnect[m
[32m+[m[32m        when a weakly referenced receiver or sender goes out of scope, as the[m
[32m+[m[32m        instance is no longer be available to be used as the sender for this[m
[32m+[m[32m        signal.[m
[32m+[m
[32m+[m[32m        An alternative approach is available by subscribing to[m
[32m+[m[32m        :attr:`receiver_connected` and setting up a custom weakref cleanup[m
[32m+[m[32m        callback on weak receivers and senders.[m
[32m+[m
[32m+[m[32m        .. versionadded:: 1.2[m
[32m+[m[32m        """[m
[32m+[m[32m        return Signal(doc="Emitted after a receiver disconnects.")[m
[32m+[m
[32m+[m[32m    def __init__(self, doc: str | None = None) -> None:[m
[32m+[m[32m        if doc:[m
[32m+[m[32m            self.__doc__ = doc[m
[32m+[m
[32m+[m[32m        self.receivers: dict[[m
[32m+[m[32m            t.Any, weakref.ref[c.Callable[..., t.Any]] | c.Callable[..., t.Any][m
[32m+[m[32m        ] = {}[m
[32m+[m[32m        """The map of connected receivers. Useful to quickly check if any[m
[32m+[m[32m        receivers are connected to the signal: ``if s.receivers:``. The[m
[32m+[m[32m        structure and data is not part of the public API, but checking its[m
[32m+[m[32m        boolean value is.[m
[32m+[m[32m        """[m
[32m+[m
[32m+[m[32m        self.is_muted: bool = False[m
[32m+[m[32m        self._by_receiver: dict[t.Any, set[t.Any]] = defaultdict(self.set_class)[m
[32m+[m[32m        self._by_sender: dict[t.Any, set[t.Any]] = defaultdict(self.set_class)[m
[32m+[m[32m        self._weak_senders: dict[t.Any, weakref.ref[t.Any]] = {}[m
[32m+[m
[32m+[m[32m    def connect(self, receiver: F, sender: t.Any = ANY, weak: bool = True) -> F:[m
[32m+[m[32m        """Connect ``receiver`` to be called when the signal is sent by[m
[32m+[m[32m        ``sender``.[m
[32m+[m
[32m+[m[32m        :param receiver: The callable to call when :meth:`send` is called with[m
[32m+[m[32m            the given ``sender``, passing ``sender`` as a positional argument[m
[32m+[m[32m            along with any extra keyword arguments.[m
[32m+[m[32m        :param sender: Any object or :data:`ANY`. ``receiver`` will only be[m
[32m+[m[32m            called when :meth:`send` is called with this sender. If ``ANY``, the[m
[32m+[m[32m            receiver will be called for any sender. A receiver may be connected[m
[32m+[m[32m            to multiple senders by calling :meth:`connect` multiple times.[m
[32m+[m[32m        :param weak: Track the receiver with a :mod:`weakref`. The receiver will[m
[32m+[m[32m            be automatically disconnected when it is garbage collected. When[m
[32m+[m[32m            connecting a receiver defined within a function, set to ``False``,[m
[32m+[m[32m            otherwise it will be disconnected when the function scope ends.[m
[32m+[m[32m        """[m
[32m+[m[32m        receiver_id = make_id(receiver)[m
[32m+[m[32m        sender_id = ANY_ID if sender is ANY else make_id(sender)[m
[32m+[m
[32m+[m[32m        if weak:[m
[32m+[m[32m            self.receivers[receiver_id] = make_ref([m
[32m+[m[32m                receiver, self._make_cleanup_receiver(receiver_id)[m
[32m+[m[32m            )[m
[32m+[m[32m        else:[m
[32m+[m[32m            self.receivers[receiver_id] = receiver[m
[32m+[m
[32m+[m[32m        self._by_sender[sender_id].add(receiver_id)[m
[32m+[m[32m        self._by_receiver[receiver_id].add(sender_id)[m
[32m+[m
[32m+[m[32m        if sender is not ANY and sender_id not in self._weak_senders:[m
[32m+[m[32m            # store a cleanup for weakref-able senders[m
[32m+[m[32m            try:[m
[32m+[m[32m                self._weak_senders[sender_id] = make_ref([m
[32m+[m[32m                    sender, self._make_cleanup_sender(sender_id)[m
[32m+[m[32m                )[m
[32m+[m[32m            except TypeError:[m
[32m+[m[32m                pass[m
[32m+[m
[32m+[m[32m        if "receiver_connected" in self.__dict__ and self.receiver_connected.receivers:[m
[32m+[m[32m            try:[m
[32m+[m[32m                self.receiver_connected.send([m
[32m+[m[32m                    self, receiver=receiver, sender=sender, weak=weak[m
[32m+[m[32m                )[m
[32m+[m[32m            except TypeError:[m
[32m+[m[32m                # TODO no explanation or test for this[m
[32m+[m[32m                self.disconnect(receiver, sender)[m
[32m+[m[32m                raise[m
[32m+[m
[32m+[m[32m        return receiver[m
[32m+[m
[32m+[m[32m    def connect_via(self, sender: t.Any, weak: bool = False) -> c.Callable[[F], F]:[m
[32m+[m[32m        """Connect the decorated function to be called when the signal is sent[m
[32m+[m[32m        by ``sender``.[m
[32m+[m
[32m+[m[32m        The decorated function will be called when :meth:`send` is called with[m
[32m+[m[32m        the given ``sender``, passing ``sender`` as a positional argument along[m
[32m+[m[32m        with any extra keyword arguments.[m
[32m+[m
[32m+[m[32m        :param sender: Any object or :data:`ANY`. ``receiver`` will only be[m
[32m+[m[32m            called when :meth:`send` is called with this sender. If ``ANY``, the[m
[32m+[m[32m            receiver will be called for any sender. A receiver may be connected[m
[32m+[m[32m            to multiple senders by calling :meth:`connect` multiple times.[m
[32m+[m[32m        :param weak: Track the receiver with a :mod:`weakref`. The receiver will[m
[32m+[m[32m            be automatically disconnected when it is garbage collected. When[m
[32m+[m[32m            connecting a receiver defined within a function, set to ``False``,[m
[32m+[m[32m            otherwise it will be disconnected when the function scope ends.=[m
[32m+[m
[32m+[m[32m        .. versionadded:: 1.1[m
[32m+[m[32m        """[m
[32m+[m
[32m+[m[32m        def decorator(fn: F) -> F:[m
[32m+[m[32m            self.connect(fn, sender, weak)[m
[32m+[m[32m            return fn[m
[32m+[m
[32m+[m[32m        return decorator[m
[32m+[m
[32m+[m[32m    @contextmanager[m
[32m+[m[32m    def connected_to([m
[32m+[m[32m        self, receiver: c.Callable[..., t.Any], sender: t.Any = ANY[m
[32m+[m[32m    ) -> c.Generator[None, None, None]:[m
[32m+[m[32m        """A context manager that temporarily connects ``receiver`` to the[m
[32m+[m[32m        signal while a ``with`` block executes. When the block exits, the[m
[32m+[m[32m        receiver is disconnected. Useful for tests.[m
[32m+[m
[32m+[m[32m        :param receiver: The callable to call when :meth:`send` is called with[m
[32m+[m[32m            the given ``sender``, passing ``sender`` as a positional argument[m
[32m+[m[32m            along with any extra keyword arguments.[m
[32m+[m[32m        :param sender: Any object or :data:`ANY`. ``receiver`` will only be[m
[32m+[m[32m            called when :meth:`send` is called with this sender. If ``ANY``, the[m
[32m+[m[32m            receiver will be called for any sender.[m
[32m+[m
[32m+[m[32m        .. versionadded:: 1.1[m
[32m+[m[32m        """[m
[32m+[m[32m        self.connect(receiver, sender=sender, weak=False)[m
[32m+[m
[32m+[m[32m        try:[m
[32m+[m[32m            yield None[m
[32m+[m[32m        finally:[m
[32m+[m[32m            self.disconnect(receiver)[m
[32m+[m
[32m+[m[32m    @contextmanager[m
[32m+[m[32m    def muted(self) -> c.Generator[None, None, None]:[m
[32m+[m[32m        """A context manager that temporarily disables the signal. No receivers[m
[32m+[m[32m        will be called if the signal is sent, until the ``with`` block exits.[m
[32m+[m[32m        Useful for tests.[m
[32m+[m[32m        """[m
[32m+[m[32m        self.is_muted = True[m
[32m+[m
[32m+[m[32m        try:[m
[32m+[m[32m            yield None[m
[32m+[m[32m        finally:[m
[32m+[m[32m            self.is_muted = False[m
[32m+[m
[32m+[m[32m    def send([m
[32m+[m[32m        self,[m
[32m+[m[32m        sender: t.Any | None = None,[m
[32m+[m[32m        /,[m
[32m+[m[32m        *,[m
[32m+[m[32m        _async_wrapper: c.Callable[[m
[32m+[m[32m            [c.Callable[..., c.Coroutine[t.Any, t.Any, t.Any]]], c.Callable[..., t.Any][m
[32m+[m[32m        ][m
[32m+[m[32m        | None = None,[m
[32m+[m[32m        **kwargs: t.Any,[m
[32m+[m[32m    ) -> list[tuple[c.Callable[..., t.Any], t.Any]]:[m
[32m+[m[32m        """Call all receivers that are connected to the given ``sender``[m
[32m+[m[32m        or :data:`ANY`. Each receiver is called with ``sender`` as a positional[m
[32m+[m[32m        argument along with any extra keyword arguments. Return a list of[m
[32m+[m[32m        ``(receiver, return value)`` tuples.[m
[32m+[m
[32m+[m[32m        The order receivers are called is undefined, but can be influenced by[m
[32m+[m[32m        setting :attr:`set_class`.[m
[32m+[m
[32m+[m[32m        If a receiver raises an exception, that exception will propagate up.[m
[32m+[m[32m        This makes debugging straightforward, with an assumption that correctly[m
[32m+[m[32m        implemented receivers will not raise.[m
[32m+[m
[32m+[m[32m        :param sender: Call receivers connected to this sender, in addition to[m
[32m+[m[32m            those connected to :data:`ANY`.[m
[32m+[m[32m        :param _async_wrapper: Will be called on any receivers that are async[m
[32m+[m[32m            coroutines to turn them into sync callables. For example, could run[m
[32m+[m[32m            the receiver with an event loop.[m
[32m+[m[32m        :param kwargs: Extra keyword arguments to pass to each receiver.[m
[32m+[m
[32m+[m[32m        .. versionchanged:: 1.7[m
[32m+[m[32m            Added the ``_async_wrapper`` argument.[m
[32m+[m[32m        """[m
[32m+[m[32m        if self.is_muted:[m
[32m+[m[32m            return [][m
[32m+[m
[32m+[m[32m        results = [][m
[32m+[m
[32m+[m[32m        for receiver in self.receivers_for(sender):[m
[32m+[m[32m            if iscoroutinefunction(receiver):[m
[32m+[m[32m                if _async_wrapper is None:[m
[32m+[m[32m                    raise RuntimeError("Cannot send to a coroutine function.")[m
[32m+[m
[32m+[m[32m                result = _async_wrapper(receiver)(sender, **kwargs)[m
[32m+[m[32m            else:[m
[32m+[m[32m                result = receiver(sender, **kwargs)[m
[32m+[m
[32m+[m[32m            results.append((receiver, result))[m
[32m+[m
[32m+[m[32m        return results[m
[32m+[m
[32m+[m[32m    async def send_async([m
[32m+[m[32m        self,[m
[32m+[m[32m        sender: t.Any | None = None,[m
[32m+[m[32m        /,[m
[32m+[m[32m        *,[m
[32m+[m[32m        _sync_wrapper: c.Callable[[m
[32m+[m[32m            [c.Callable[..., t.Any]], c.Callable[..., c.Coroutine[t.Any, t.Any, t.Any]][m
[32m+[m[32m        ][m
[32m+[m[32m        | None = None,[m
[32m+[m[32m        **kwargs: t.Any,[m
[32m+[m[32m    ) -> list[tuple[c.Callable[..., t.Any], t.Any]]:[m
[32m+[m[32m        """Await all receivers that are connected to the given ``sender``[m
[32m+[m[32m        or :data:`ANY`. Each receiver is called with ``sender`` as a positional[m
[32m+[m[32m        argument along with any extra keyword arguments. Return a list of[m
[32m+[m[32m        ``(receiver, return value)`` tuples.[m
[32m+[m
[32m+[m[32m        The order receivers are called is undefined, but can be influenced by[m
[32m+[m[32m        setting :attr:`set_class`.[m
[32m+[m
[32m+[m[32m        If a receiver raises an exception, that exception will propagate up.[m
[32m+[m[32m        This makes debugging straightforward, with an assumption that correctly[m
[32m+[m[32m        implemented receivers will not raise.[m
[32m+[m
[32m+[m[32m        :param sender: Call receivers connected to this sender, in addition to[m
[32m+[m[32m            those connected to :data:`ANY`.[m
[32m+[m[32m        :param _sync_wrapper: Will be called on any receivers that are sync[m
[32m+[m[32m            callables to turn them into async coroutines. For example,[m
[32m+[m[32m            could call the receiver in a thread.[m
[32m+[m[32m        :param kwargs: Extra keyword arguments to pass to each receiver.[m
[32m+[m
[32m+[m[32m        .. versionadded:: 1.7[m
[32m+[m[32m        """[m
[32m+[m[32m        if self.is_muted:[m
[32m+[m[32m            return [][m
[32m+[m
[32m+[m[32m        results = [][m
[32m+[m
[32m+[m[32m        for receiver in self.receivers_for(sender):[m
[32m+[m[32m            if not iscoroutinefunction(receiver):[m
[32m+[m[32m                if _sync_wrapper is None:[m
[32m+[m[32m                    raise RuntimeError("Cannot send to a non-coroutine function.")[m
[32m+[m
[32m+[m[32m                result = await _sync_wrapper(receiver)(sender, **kwargs)[m
[32m+[m[32m            else:[m
[32m+[m[32m                result = await receiver(sender, **kwargs)[m
[32m+[m
[32m+[m[32m            results.append((receiver, result))[m
[32m+[m
[32m+[m[32m        return results[m
[32m+[m
[32m+[m[32m    def has_receivers_for(self, sender: t.Any) -> bool:[m
[32m+[m[32m        """Check if there is at least one receiver that will be called with the[m
[32m+[m[32m        given ``sender``. A receiver connected to :data:`ANY` will always be[m
[32m+[m[32m        called, regardless of sender. Does not check if weakly referenced[m
[32m+[m[32m        receivers are still live. See :meth:`receivers_for` for a stronger[m
[32m+[m[32m        search.[m
[32m+[m
[32m+[m[32m        :param sender: Check for receivers connected to this sender, in addition[m
[32m+[m[32m            to those connected to :data:`ANY`.[m
[32m+[m[32m        """[m
[32m+[m[32m        if not self.receivers:[m
[32m+[m[32m            return False[m
[32m+[m
[32m+[m[32m        if self._by_sender[ANY_ID]:[m
[32m+[m[32m            return True[m
[32m+[m
[32m+[m[32m        if sender is ANY:[m
[32m+[m[32m            return False[m
[32m+[m
[32m+[m[32m        return make_id(sender) in self._by_sender[m
[32m+[m
[32m+[m[32m    def receivers_for([m
[32m+[m[32m        self, sender: t.Any[m
[32m+[m[32m    ) -> c.Generator[c.Callable[..., t.Any], None, None]:[m
[32m+[m[32m        """Yield each receiver to be called for ``sender``, in addition to those[m
[32m+[m[32m        to be called for :data:`ANY`. Weakly referenced receivers that are not[m
[32m+[m[32m        live will be disconnected and skipped.[m
[32m+[m
[32m+[m[32m        :param sender: Yield receivers connected to this sender, in addition[m
[32m+[m[32m            to those connected to :data:`ANY`.[m
[32m+[m[32m        """[m
[32m+[m[32m        # TODO: test receivers_for(ANY)[m
[32m+[m[32m        if not self.receivers:[m
[32m+[m[32m            return[m
[32m+[m
[32m+[m[32m        sender_id = make_id(sender)[m
[32m+[m
[32m+[m[32m        if sender_id in self._by_sender:[m
[32m+[m[32m            ids = self._by_sender[ANY_ID] | self._by_sender[sender_id][m
[32m+[m[32m        else:[m
[32m+[m[32m            ids = self._by_sender[ANY_ID].copy()[m
[32m+[m
[32m+[m[32m        for receiver_id in ids:[m
[32m+[m[32m            receiver = self.receivers.get(receiver_id)[m
[32m+[m
[32m+[m[32m            if receiver is None:[m
[32m+[m[32m                continue[m
[32m+[m
[32m+[m[32m            if isinstance(receiver, weakref.ref):[m
[32m+[m[32m                strong = receiver()[m
[32m+[m
[32m+[m[32m                if strong is None:[m
[32m+[m[32m                    self._disconnect(receiver_id, ANY_ID)[m
[32m+[m[32m                    continue[m
[32m+[m
[32m+[m[32m                yield strong[m
[32m+[m[32m            else:[m
[32m+[m[32m                yield receiver[m
[32m+[m
[32m+[m[32m    def disconnect(self, receiver: c.Callable[..., t.Any], sender: t.Any = ANY) -> None:[m
[32m+[m[32m        """Disconnect ``receiver`` from being called when the signal is sent by[m
[32m+[m[32m        ``sender``.[m
[32m+[m
[32m+[m[32m        :param receiver: A connected receiver callable.[m
[32m+[m[32m        :param sender: Disconnect from only this sender. By default, disconnect[m
[32m+[m[32m            from all senders.[m
[32m+[m[32m        """[m
[32m+[m[32m        sender_id: c.Hashable[m
[32m+[m
[32m+[m[32m        if sender is ANY:[m
[32m+[m[32m            sender_id = ANY_ID[m
[32m+[m[32m        else:[m
[32m+[m[32m            sender_id = make_id(sender)[m
[32m+[m
[32m+[m[32m        receiver_id = make_id(receiver)[m
[32m+[m[32m        self._disconnect(receiver_id, sender_id)[m
[32m+[m
[32m+[m[32m        if ([m
[32m+[m[32m            "receiver_disconnected" in self.__dict__[m
[32m+[m[32m            and self.receiver_disconnected.receivers[m
[32m+[m[32m        ):[m
[32m+[m[32m            self.receiver_disconnected.send(self, receiver=receiver, sender=sender)[m
[32m+[m
[32m+[m[32m    def _disconnect(self, receiver_id: c.Hashable, sender_id: c.Hashable) -> None:[m
[32m+[m[32m        if sender_id == ANY_ID:[m
[32m+[m[32m            if self._by_receiver.pop(receiver_id, None) is not None:[m
[32m+[m[32m                for bucket in self._by_sender.values():[m
[32m+[m[32m                    bucket.discard(receiver_id)[m
[32m+[m
[32m+[m[32m            self.receivers.pop(receiver_id, None)[m
[32m+[m[32m        else:[m
[32m+[m[32m            self._by_sender[sender_id].discard(receiver_id)[m
[32m+[m[32m            self._by_receiver[receiver_id].discard(sender_id)[m
[32m+[m
[32m+[m[32m    def _make_cleanup_receiver([m
[32m+[m[32m        self, receiver_id: c.Hashable[m
[32m+[m[32m    ) -> c.Callable[[weakref.ref[c.Callable[..., t.Any]]], None]:[m
[32m+[m[32m        """Create a callback function to disconnect a weakly referenced[m
[32m+[m[32m        receiver when it is garbage collected.[m
[32m+[m[32m        """[m
[32m+[m
[32m+[m[32m        def cleanup(ref: weakref.ref[c.Callable[..., t.Any]]) -> None:[m
[32m+[m[32m            # If the interpreter is shutting down, disconnecting can result in a[m
[32m+[m[32m            # weird ignored exception. Don't call it in that case.[m
[32m+[m[32m            if not sys.is_finalizing():[m
[32m+[m[32m                self._disconnect(receiver_id, ANY_ID)[m
[32m+[m
[32m+[m[32m        return cleanup[m
[32m+[m
[32m+[m[32m    def _make_cleanup_sender([m
[32m+[m[32m        self, sender_id: c.Hashable[m
[32m+[m[32m    ) -> c.Callable[[weakref.ref[t.Any]], None]:[m
[32m+[m[32m        """Create a callback function to disconnect all receivers for a weakly[m
[32m+[m[32m        referenced sender when it is garbage collected.[m
[32m+[m[32m        """[m
[32m+[m[32m        assert sender_id != ANY_ID[m
[32m+[m
[32m+[m[32m        def cleanup(ref: weakref.ref[t.Any]) -> None:[m
[32m+[m[32m            self._weak_senders.pop(sender_id, None)[m
[32m+[m
[32m+[m[32m            for receiver_id in self._by_sender.pop(sender_id, ()):[m
[32m+[m[32m                self._by_receiver[receiver_id].discard(sender_id)[m
[32m+[m
[32m+[m[32m        return cleanup[m
[32m+[m
[32m+[m[32m    def _cleanup_bookkeeping(self) -> None:[m
[32m+[m[32m        """Prune unused sender/receiver bookkeeping. Not threadsafe.[m
[32m+[m
[32m+